#!/usr/bin/env python3
"""fzfui: Interactive fzf interfaces for grimaur and gpmwrap.

Provides fuzzy-finding interfaces for package management operations.

## /* SPDX-FileCopyrightText: 2025
# (O) Eihdran L. <hadean-eon-dev@proton.me>

##  SPDX-License-Identifier: MIT */

Requirements: fzf, grimaur, gpmwrap
"""
from __future__ import annotations

import argparse
import subprocess
import sys
from collections.abc import Sequence
from dataclasses import dataclass
from importlib.machinery import SourceFileLoader
from importlib.util import module_from_spec, spec_from_loader
from pathlib import Path

# Load grimaur
file_path = f'{Path(__file__).parent}/grimaur'
s = spec_from_loader('grimaur', SourceFileLoader('grimaur', file_path), origin=file_path)
g = module_from_spec(s)
sys.modules['grimaur'] = g
s.loader.exec_module(g)

# Load gpmwrap
file_path_gpm = f'{Path(__file__).parent}/gpmrap'
s_gpm = spec_from_loader('gpmwrap', SourceFileLoader('gpmwrap', file_path_gpm), origin=file_path_gpm)
gpm = module_from_spec(s_gpm)
sys.modules['gpmwrap'] = gpm
s_gpm.loader.exec_module(gpm)

script_path = Path(__file__).resolve()

g.USE_COLOR = sys.stdout.isatty()


@dataclass
class FzfResult:
    selected: list[str]
    query: str
    key: str | None = None


def run_fzf(
    items: Sequence[str],
    *,
    prompt: str = '> ',
    multi: bool = False,
    preview: str | None = None,
    header: str | None = None,
    bind: dict[str, str] | None = None,
) -> FzfResult | None:
    """Run fzf with given items and options."""
    cmd = ['fzf', '--prompt', prompt]

    if multi:
        cmd.append('--multi')
    if preview:
        cmd.extend(['--preview', preview])
    if header:
        cmd.extend(['--header', header])
    if bind:
        for key, action in bind.items():
            cmd.extend(['--bind', f'{key}:{action}'])

    try:
        proc = subprocess.run(
            cmd,
            input='\n'.join(items),
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print(g.style('fzf not found. Install fzf to use this tool.', g.YELLOW), file=sys.stderr)
        return None

    if proc.returncode == 130:  # Cancelled
        return None

    lines = proc.stdout.strip().split('\n')
    if not lines or lines == ['']:
        return None

    selected = [line for line in lines if line]

    return FzfResult(selected=selected, query='', key=None)


def _flatpak_info_output(app_id: str) -> None:
    """Output formatted flatpak info for preview pane."""
    try:
        result = subprocess.run(
            ['flatpak', 'remote-info', 'flathub', app_id],
            capture_output=True, text=True
        )
        if result.returncode != 0:
            print('No info available')
            return

        for line in result.stdout.splitlines():
            # Strip trailing whitespace and normalize leading whitespace
            line = line.rstrip()
            if ':' in line:
                # Split on first colon, left-align label
                parts = line.split(':', 1)
                label = parts[0].strip()
                value = parts[1].strip() if len(parts) > 1 else ''
                print(f"{label}: {value}")
            else:
                # Description line or other content
                print(line.strip())
    except FileNotFoundError:
        print('flatpak not found')


def _get_flatpak_installed() -> set[str]:
    """Get set of installed flatpak app IDs."""
    try:
        result = subprocess.run(
            ['flatpak', 'list', '--app', '--columns=application'],
            capture_output=True, text=True
        )
        return set(line.strip() for line in result.stdout.splitlines() if line.strip())
    except FileNotFoundError:
        return set()


def _get_all_flatpaks() -> list[str]:
    """Get all flatpaks from flathub with installed markers."""
    installed = _get_flatpak_installed()
    items = []
    try:
        result = subprocess.run(
            ['flatpak', 'remote-ls', 'flathub', '--app', '--columns=name,application,description'],
            capture_output=True, text=True
        )
        for line in result.stdout.splitlines():
            if line.strip():
                parts = line.split('\t')
                if len(parts) >= 2:
                    name = parts[0].strip()[:25]
                    app_id = parts[1].strip()
                    desc = parts[2].strip()[:40] if len(parts) > 2 else ''
                    marker = '• ' if app_id in installed else '  '
                    # Pad app_id to 45 chars for alignment
                    items.append(f"{marker}{name:<25}\t{app_id:<45}\t{desc}")
    except FileNotFoundError:
        pass
    return items


def search_flatpak() -> None:
    """Interactive flatpak browser with fzf."""
    # Get all flatpaks from flathub
    items = _get_all_flatpaks()

    if not items:
        print(g.style('No flatpaks found. Is flathub remote configured?', g.YELLOW), file=sys.stderr)
        return

    # Preview command using Python helper for clean formatting
    preview_cmd = f"python {script_path} _flatpak_info $(echo {{}} | cut -f2)"

    cmd = [
        'fzf',
        '--prompt', 'Flatpak> ',
        '--header', '• = installed | TAB to select, ENTER to install/remove',
        '--multi',
        '--delimiter', '\t',
        '--tiebreak=begin,index',  # Prefer matches at start (name/id before desc)
        '--preview', preview_cmd,
        '--preview-window', 'right:50%:wrap',
    ]

    try:
        proc = subprocess.run(
            cmd,
            input='\n'.join(items),
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print(g.style('fzf not found.', g.YELLOW), file=sys.stderr)
        return

    if proc.returncode == 130 or not proc.stdout.strip():
        return

    selected = [line for line in proc.stdout.strip().split('\n') if line]
    if not selected:
        return

    installed = _get_flatpak_installed()
    to_install = []
    to_remove = []

    for line in selected:
        # Extract app ID (field 2, tab-delimited)
        # Line format: "• Name\tapp.id\tDescription" or "  Name\tapp.id\tDescription"
        clean_line = line.lstrip('• ')
        parts = clean_line.split('\t')
        if len(parts) >= 2:
            app_id = parts[1].strip()
            if app_id in installed:
                to_remove.append(app_id)
            else:
                to_install.append(app_id)

    for app_id in to_remove:
        print(g.style(f'Removing: {app_id}', g.CYAN))
        try:
            g.run_command(['flatpak', 'uninstall', '-y', app_id])
        except g.PacAurGitFpError as e:
            print(g.style(f'Error: {e}', g.YELLOW), file=sys.stderr)

    for app_id in to_install:
        print(g.style(f'Installing: {app_id}', g.CYAN))
        try:
            g.run_command(['flatpak', 'install', '-y', 'flathub', app_id])
        except g.PacAurGitFpError as e:
            print(g.style(f'Error: {e}', g.YELLOW), file=sys.stderr)


def _format_aur_results(results) -> list[str]:
    items = []
    for r in results:
        installed = '[installed]' if r.installed else ''
        items.append(f"{r.name:<35} {r.version or '':<15} {installed}")
    return items


def _aur_search_output(query: str) -> None:
    if len(query) < 2:
        return
    results = g.search_packages(query, regex=None, needle=query.lower(), limit=100)
    for line in _format_aur_results(results):
        print(line)


def _get_aur_packages_alphabetical(limit: int = 100) -> list[str]:
    # Sorting like aur page
    try:
        output = g.run_command(
            ["git", "ls-remote", "--heads", g.get_aur_remote()],
            capture=True
        )
    except g.PacAurGitFpError:
        return []

    packages = []
    for line in str(output).splitlines():
        if not line.strip():
            continue
        # Format: <sha>\trefs/heads/<package>
        parts = line.split('\t')
        if len(parts) == 2 and parts[1].startswith('refs/heads/'):
            name = parts[1][len('refs/heads/'):]
            packages.append(name)

    packages.sort()
    return packages[:limit]


def search_aur() -> None:
    # Initial load - first 100 packages alphabetically
    initial_packages = _get_aur_packages_alphabetical(100)
    initial_items = [f"{name:<35}" for name in initial_packages]

    cmd = [
        'fzf',
        '--prompt', 'AUR> ',
        '--header', 'Type to search AUR, TAB to select, ENTER to install/remove',
        '--multi',
        '--bind', f'change:reload:python {script_path} _aur {{q}} 2>/dev/null || true',
        '--preview', f'python {file_path} info {{1}} --full 2>/dev/null || python {file_path} info {{1}} --target PKGBUILD 2>/dev/null || python {file_path} info {{1}} --target SRCINFO 2>/dev/null || echo "No info"',
    ]

    try:
        proc = subprocess.run(
            cmd,
            input='\n'.join(initial_items),
            capture_output=True,
            text=True,
        )
    except FileNotFoundError:
        print(g.style('fzf not found.', g.YELLOW), file=sys.stderr)
        return

    if proc.returncode == 130 or not proc.stdout.strip():
        return

    selected = [line for line in proc.stdout.strip().split('\n') if line]
    if not selected:
        return

    result = FzfResult(selected=selected, query='', key=None)

    if not result or not result.selected:
        return

    installed_set = g.installed_package_set()
    to_install = []
    to_remove = []

    for line in result.selected:
        pkg = line.split()[0]
        if pkg in installed_set:
            to_remove.append(pkg)
        else:
            to_install.append(pkg)

    for pkg in to_remove:
        print(g.style(f'Removing: {pkg}', g.CYAN))
        gpm.remove_package(pkg, dependencies=True)

    for pkg in to_install:
        print(g.style(f'Installing: {pkg}', g.CYAN))
        try:
            g.install_package(pkg, dest_root=Path, refresh=False, noconfirm=False)
        except g.PacAurGitFpError as e:
            print(g.style(f'Error installing {pkg}: {e}', g.YELLOW), file=sys.stderr)


def search_sync() -> None:
    # Get all sync packages using gpmwrap's list_all
    entries = gpm.list_all(local=False, parse=True)

    items = []
    for e in entries:
        installed = '[installed]' if e.installed else ''
        items.append(f"{e.name:<35} {e.repo:<12} {e.version:<20} {installed}")

    result = run_fzf(
        items,
        prompt='Sync> ',
        multi=True,
        header='TAB to select, ENTER to toggle install/remove',
        preview='pacman -Si {1} 2>/dev/null || echo "Loading..."',
    )

    if not result or not result.selected:
        return

    packages = [line.split()[0] for line in result.selected]

    # Toggle based on installed state
    installed_set = g.installed_package_set()
    for pkg in packages:
        if pkg in installed_set:
            gpm.remove_package(pkg, dependencies=True)
        else:
            gpm.install_package(pkg)


def search_installed() -> None:
    """Interactive installed package browser with fzf."""
    entries = gpm.list_installed(parse=True)
    foreign = g.list_foreign_packages()

    items = []
    for e in entries:
        marker = ' [foreign]' if e.name in foreign else ''
        items.append(f"{e.name:<35} {e.version}{marker}")

    result = run_fzf(
        items,
        prompt='Installed> ',
        multi=True,
        header='TAB to select, ENTER to remove. [foreign]=not in repos',
        preview='pacman -Qi {1} 2>/dev/null',
    )

    if not result or not result.selected:
        return

    packages = [line.split()[0] for line in result.selected]

    for pkg in packages:
        gpm.remove_package(pkg, dependencies=True)


def toggle_repos() -> None:
    """Interactive repository toggle menu with fzf."""
    repos = gpm.get_repos()

    items = []
    for name, enabled in repos:
        status = '[enabled]' if enabled else '[disabled]'
        items.append(f"{name:<20} {status}")

    result = run_fzf(
        items,
        prompt='Repos> ',
        multi=True,
        header='TAB to select, ENTER to toggle',
    )

    if not result or not result.selected:
        return

    for line in result.selected:
        repo_name = line.split()[0]
        gpm.toggle_repo(repo_name)

        sync_cmd = ['pacman', '-Sy']
        g.needs_sudo(sync_cmd)
        g.run_command(sync_cmd)


def toggle_colors() -> None:
    """Toggle Color in pacman.conf."""
    gpm.toggle_color('Color')


def toggle_candy() -> None:
    """Toggle ILoveCandy in pacman.conf."""
    with open("/etc/pacman.conf") as f:
        lines = f.readlines()

    has_candy = any(line.strip() == "ILoveCandy" for line in lines)
    has_candy_commented = any(line.strip() == "#ILoveCandy" for line in lines)

    # If ILoveCandy doesn't exist at all, add it after Color
    if not has_candy and not has_candy_commented:
        new_lines = []
        for line in lines:
            new_lines.append(line)
            if line.strip() in ('Color', '#Color'):
                new_lines.append('ILoveCandy\n')
        with open("/etc/pacman.conf", "w") as f:
            f.writelines(new_lines)
    else:
        gpm.toggle_color('ILoveCandy')


def main_menu() -> None:
    """Main menu for fzf interface."""
    import os

    if os.geteuid() == 0:
        menu = [
            'repos\tToggle pacman.conf repositories',
            'colors\tToggle pacman colors',
            'pacman-anim\tToggle pacman animation (ILoveCandy)',
        ]
    else:
        menu = [
            f"{'search-aur':<12}\tSearch AUR packages",
            f"{'search-sync':<12}\tSearch official repo packages",
            f"{'search-fp':<12}\tSearch Flathub packages",
            f"{'installed':<12}\tBrowse installed packages",
        ]

    result = run_fzf(
        menu,
        prompt='grur> ',
        header='Select an action',
    )

    if not result or not result.selected:
        return

    choice = result.selected[0].split('\t')[0].strip()

    if choice == 'search-aur':
        search_aur()
    elif choice == 'search-sync':
        search_sync()
    elif choice == 'search-fp':
        search_flatpak()
    elif choice == 'installed':
        search_installed()
    elif choice == 'repos':
        toggle_repos()
    elif choice == 'colors':
        toggle_colors()
    elif choice == 'pacman-anim':
        toggle_candy()


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog='fzfui',
        description='Interactive fzf interfaces for package management'
    )
    subparsers = parser.add_subparsers(dest='command')

    subparsers.add_parser('menu', help='Show main menu')
    subparsers.add_parser('aur', help='Search AUR packages')
    subparsers.add_parser('sync', help='Search sync repo packages')
    subparsers.add_parser('search-fp', help='Search Flathub packages')
    subparsers.add_parser('installed', help='Browse installed packages')
    subparsers.add_parser('repos', help='Toggle pacman.conf repositories')

    # Internal: fzf helpers
    aur_reload = subparsers.add_parser('_aur')
    aur_reload.add_argument('query', nargs='?', default='')

    flatpak_info = subparsers.add_parser('_flatpak_info')
    flatpak_info.add_argument('app_id', nargs='?', default='')

    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.command is None or args.command == 'menu':
        main_menu()
    elif args.command == 'aur':
        search_aur()
    elif args.command == 'sync':
        search_sync()
    elif args.command == 'search-fp':
        search_flatpak()
    elif args.command == 'installed':
        search_installed()
    elif args.command == 'repos':
        toggle_repos()
    elif args.command == '_aur':
        _aur_search_output(args.query)
    elif args.command == '_flatpak_info':
        _flatpak_info_output(args.app_id)

    return 0


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print(g.style('\nInterrupted by user', g.YELLOW), file=sys.stderr)
        sys.exit(130)
