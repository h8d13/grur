#!/usr/bin/env python3
"""gpmwrap: Wraps common pacman operations

Uses grimaur's tools directly but aims to only be for direct management of a system pkgs
Without thinking about the AUR. It copies some ideas from Debian and added logic for pacman.

Notably terms 'install' and 'uninstall' but also support for 'install package-' which is uninstall.

## /* SPDX-FileCopyrightText: 2025
# (O) Eihdran L. <hadean-eon-dev@proton.me>

##  SPDX-License-Identifier: MIT */

Requirements: pacman, pacman-contrib, reflector, sudo/root
"""
import re
import sys
from importlib.util import spec_from_loader, module_from_spec
from importlib.machinery import SourceFileLoader
from pathlib import Path
from dataclasses import dataclass
import argparse

# Dirty python trick
file_name = 'grimaur'
file_path = f'{Path.cwd()}/{file_name}'

s = spec_from_loader(
            file_name,
            SourceFileLoader(file_name, file_path),
            origin=file_path
        )

g = module_from_spec(s)
sys.modules['grimaur'] = g

# Load and call from source file
# Allows us to use grimaur like an API without using .py extensions
s.loader.exec_module(g)

@dataclass
class LocalFileEntry:
    """Model for pacman -Ql output: package_name /path/to/file"""
    name: str
    file: str

@dataclass
class InstalledPackageEntry:
    """Model for pacman -Q output: package_name version"""
    name: str
    version: str

@dataclass
class SyncPackageEntry:
    """Model for pacman -Sl output: repo package_name version [installed]"""
    repo: str
    name: str
    version: str
    installed: bool = False

g.USE_COLOR = '--no-color' not in sys.argv

ARROW = '==>'
def op_a(text):
    print(f"{g.style(ARROW, g.GREEN)} {text}...")

# pacman-contrib related
def check_updates():
    op_a('checking updates')
    try:
        g.run_command(['checkupdates'])
    except g.PacAurGitFpError as e:
        if "exit code 2" in str(e):
            op_a('system up to date')
        else:
            raise

def clean_packages():
    op_a('cleaning packages')
    g.run_command(['paccache', '-r'])

def show_dependencies(package):
    op_a('showing deps')
    g.run_command(['pactree', package])

# reflector
def sort_mirrors(
    protocol: str = 'https',
    latest: int = 20,
    sort: str = 'rate',
    country: str | None = None,
    save: str = '/etc/pacman.d/mirrorlist',
    sync_after: bool = True,
    dry_run: bool = False,
):
    """Sort mirrors using reflector and optionally sync databases."""
    if dry_run:
        op_a('sorting mirrors with reflector (dry run)')
    else:
        op_a('sorting mirrors with reflector')

    cmd = ['reflector']

    if protocol:
        cmd.extend(['--protocol', protocol])
    if latest:
        cmd.extend(['--latest', str(latest)])
    if sort:
        cmd.extend(['--sort', sort])
    if country:
        cmd.extend(['--country', country])
    if save and not dry_run:
        cmd.extend(['--save', save])
        g.needs_sudo(cmd)

    g.run_command(cmd)

    if sync_after and not dry_run:
        sync_cmd = ['pacman', '-Sy']
        g.needs_sudo(sync_cmd)
        g.run_command(sync_cmd)

# Helpers
def parse_local_files(output: str) -> list[LocalFileEntry]:
    """Parse pacman -Ql output into structured entries."""
    entries = []
    for line in output.strip().splitlines():
        parts = line.split(None, 1)
        if len(parts) == 2:
            entries.append(LocalFileEntry(name=parts[0], file=parts[1]))
    return entries

def parse_installed_list(output: str) -> list[InstalledPackageEntry]:
    """Parse pacman -Q output into structured entries."""
    entries = []
    for line in output.strip().splitlines():
        parts = line.split()
        if len(parts) >= 2:
            entries.append(InstalledPackageEntry(name=parts[0], version=parts[1]))
    return entries

def parse_sync_list(output: str) -> list[SyncPackageEntry]:
    """Parse pacman -Sl output into structured entries."""
    entries = []
    for line in output.strip().splitlines():
        parts = line.split()
        if len(parts) >= 3:
            repo, name, version = parts[0], parts[1], parts[2]
            installed = len(parts) > 3 and parts[3] == '[installed]'
            entries.append(SyncPackageEntry(repo=repo, name=name, version=version, installed=installed))
    return entries

# Repository management
def get_repos() -> list[tuple[str, bool]]:
    """Return list of (repo_name, enabled) tuples from pacman.conf."""
    repos = []
    with open("/etc/pacman.conf") as f:
        for line in f:
            match = re.match(r'^(#?)\s*\[([^\]]+)\]', line.strip())
            if match and match.group(2) not in ('options', 'custom'):
                repos.append((match.group(2), not match.group(1)))
    return repos

def toggle_repo(repo_name: str) -> None:
    """Toggle a repository on/off in pacman.conf."""
    with open("/etc/pacman.conf") as f:
        lines = f.readlines()

    new = []
    skip_include = False
    for line in lines:
        stripped = line.strip()

        # Handle Include line after repo toggle
        if skip_include:
            skip_include = False
            if 'Include' in stripped:
                if stripped.startswith('#'):
                    new.append(re.sub(r'^#\s*', '', line))
                else:
                    new.append('#' + line)
                continue

        match = re.match(r'^(#?)\s*\[([^\]]+)\]', stripped)
        if match and match.group(2) == repo_name:
            if match.group(1):  # Currently commented, enable it
                new.append(re.sub(r'^#\s*', '', line))
            else:  # Currently enabled, disable it
                new.append('#' + line)
            skip_include = True
            continue

        new.append(line)

    with open("/etc/pacman.conf", "w") as f:
        f.writelines(new)

def toggle_color(option: str) -> None:
    """Toggle Color or ILoveCandy in pacman.conf."""
    with open("/etc/pacman.conf") as f:
        lines = f.readlines()

    new = []
    for line in lines:
        stripped = line.strip()

        if stripped == option:
            new.append(f'#{option}\n')
            continue
        elif stripped == f'#{option}':
            new.append(f'{option}\n')
            continue

        new.append(line)

    with open("/etc/pacman.conf", "w") as f:
        f.writelines(new)

# Start actual functions
def list_installed(parse: bool = False) -> list[InstalledPackageEntry] | str:
    """List installed packages with versions (-Q)."""
    if not parse:
        op_a('listing installed packages')
    results = g.run_command(['pacman', '-Q'], capture=True)
    if parse:
        return parse_installed_list(str(results))
    print(results)
    return str(results)

def list_all(local=True, parse=False):
    """List package files (-Ql) or sync packages (-Sl)."""
    if local:
        flags = "-Ql"
        if not parse:
            op_a('listing installed package files')
    else:
        flags = "-Sl"
        if not parse:
            op_a('listing sync packages')

    results = g.run_command(['pacman', flags], capture=True)

    if parse:
        if local:
            return parse_local_files(str(results))
        else:
            return parse_sync_list(str(results))

    print(results)
    return results

def search_packages(package, local=False, exact=False, limit=None):

    if local:
        # -Q    = installed package exact returns single line
        # -Qs   = installed packages name | descriptions matches returns 2 lines per
        flag = '-Q' if exact else '-Qs'
        op_a(f'searching installed packages for {package}')
    else:
        # -Ss   = Search sync dbs returns 2 lines per
        flag = '-Ss'
        op_a(f'searching sync repos for {package}')

    cmd = ['pacman', flag]
    if g.USE_COLOR:
        cmd.append('--color=always')
    cmd.append(package)

    try:
        results = g.run_command(cmd, capture=True)
        output = str(results)
        lines = output.splitlines()

        # Sort results by relevance using grimaur's scoring
        if not exact and len(lines) >= 2:
            ansi_escape = re.compile(r'\x1b\[[0-9;]*m')
            pairs = []
            current_header = None
            current_desc = []

            for line in lines:
                clean_line = ansi_escape.sub('', line)
                if clean_line and not clean_line[0].isspace():
                    if current_header is not None:
                        pairs.append((current_header, '\n'.join(current_desc)))
                    current_header = line
                    current_desc = []
                else:
                    current_desc.append(line)

            if current_header is not None:
                pairs.append((current_header, '\n'.join(current_desc)))

            def score(pair):
                clean = ansi_escape.sub('', pair[0])
                name_part = clean.split()[0] if clean.split() else ''
                name = name_part.split('/')[-1] if '/' in name_part else name_part
                s = g.compute_match_score(name, regex=None, needle=package.lower())
                return s if s is not None else 999999

            pairs.sort(key=score, reverse=True)  # Best matches last (like grimaur)
            lines = []
            for pair in pairs:
                lines.append(pair[0])
                if pair[1]:
                    lines.append(pair[1])

        if limit and limit > 0 and not exact:
            # Limit by number of packages - take best matches (from end since reversed)
            ansi_escape = re.compile(r'\x1b\[[0-9;]*m')
            all_pairs = []
            current_header = None
            current_desc = []

            for line in lines:
                clean_line = ansi_escape.sub('', line)
                if clean_line and not clean_line[0].isspace():
                    if current_header is not None:
                        all_pairs.append((current_header, current_desc))
                    current_header = line
                    current_desc = []
                else:
                    current_desc.append(line)

            if current_header is not None:
                all_pairs.append((current_header, current_desc))

            # Take last N pairs (best matches are at the end)
            limited_pairs = all_pairs[-limit:]

            lines = []
            for header, desc in limited_pairs:
                lines.append(header)
                lines.extend(desc)

        output = '\n'.join(lines)
        print(output)
        return output
    except g.PacAurGitFpError:
        print(f"Package '{package}' was not found.")

def inspect_package(package, local=False):

    if local:
        op_a(f'inspecting installed {package}')
        cmd = ['pacman', '-Qi', package]
    else:
        op_a(f'inspecting sync {package}')
        cmd = ['pacman', '-Si', package]

    if g.USE_COLOR:
        cmd.insert(1, '--color=always')

    try:
        results = g.run_command(cmd, capture=True)
        print(results)
    except g.PacAurGitFpError as e:
        msg = str(e)
        print(g.style(msg, g.YELLOW), file=sys.stderr)

def install_package(package):

    op_a(f'installing {package}')
    cmd = ['pacman', '-S', package]

    g.needs_sudo(cmd)
    try:
        g.run_command(cmd, check=True)
        print(g.style(f'Sucessfully installed {package}', g.GREEN), file=sys.stderr)
    except g.PacAurGitFpError as e:
        msg = str(e)
        print(g.style(msg, g.YELLOW), file=sys.stderr)

def remove_package(package, dependencies=True):

    op_a(f'uninstalling {package}')
    if dependencies:
        cmd = ['pacman', '-Rns', package]
    else:
        cmd = ['pacman', '-R', package]

    g.needs_sudo(cmd)
    try:
        g.run_command(cmd, check=True)
        print(g.style(f'Sucessfully uninstalled {package}', g.GREEN), file=sys.stderr)
    except g.PacAurGitFpError as e:
        msg = str(e)
        print(g.style(msg, g.YELLOW), file=sys.stderr)

# Main execution flow
def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog='gpmwrap',
        description='Wrapper for common pacman operations (requires pacman-contrib)'
    )
    parser.add_argument(
        '--no-color',
        action='store_true',
        help='Disable colored output',
    )
    parser.add_argument(
        '--noconfirm',
        action='store_true',
        help='Skip confirmation prompts',
    )
    subparsers = parser.add_subparsers(dest='command')

    # mirrors - sort mirrors with reflector
    mirrors_parser = subparsers.add_parser(
        'mirrors',
        help='Sort mirrors using reflector'
    )
    mirrors_parser.add_argument(
        '--protocol', '-p',
        default='https',
        help='Mirror protocol (default: https)'
    )
    mirrors_parser.add_argument(
        '--latest', '-l',
        type=int,
        default=20,
        help='Number of latest mirrors to use (default: 20)'
    )
    mirrors_parser.add_argument(
        '--sort', '-s',
        default='rate',
        choices=['rate', 'age', 'score', 'country'],
        help='Sort method (default: rate)'
    )
    mirrors_parser.add_argument(
        '--country', '-c',
        help='Filter by country (e.g., US, DE, FR)'
    )
    mirrors_parser.add_argument(
        '--dry-run', '-n',
        action='store_true',
        help='Print mirrors without saving to mirrorlist'
    )

    # sync - sync package databases
    subparsers.add_parser(
        'sync',
        help='Sync package databases (pacman -Sy)'
    )

    # upgrade - full system upgrade
    upgrade_parser = subparsers.add_parser(
        'upgrade',
        help='Full system upgrade (pacman -Syu)'
    )
    upgrade_group = upgrade_parser.add_mutually_exclusive_group()
    upgrade_group.add_argument(
        '--download', '-w',
        action='store_true',
        help='Download packages without installing (pacman -Syuw)'
    )
    upgrade_group.add_argument(
        '--install', '-u',
        action='store_true',
        help='Install already-downloaded packages (pacman -Su)'
    )

    # check - check for updates
    subparsers.add_parser(
        'check',
        help='Check for available updates (uses checkupdates from pacman-contrib)'
    )

    # clean - clean package cache
    subparsers.add_parser(
        'clean',
        aliases=['sif'],
        help='Clean old packages from cache (uses paccache -r)'
    )

    # deps - show dependency tree
    deps_parser = subparsers.add_parser(
        'deps',
        help='Show dependency tree for a package (uses pactree)'
    )
    deps_parser.add_argument('package', help='Package name to show dependencies for')

    # list - list packages
    list_parser = subparsers.add_parser(
        'list',
        help='List packages and their files'
    )
    list_parser.add_argument(
        '--sync', '-s',
        action='store_true',
        help='List from sync repos instead of installed packages'
    )

    # search - search packages
    search_parser = subparsers.add_parser(
        'search',
        help='Search for packages'
    )
    search_parser.add_argument('package', help='Package name or pattern to search')
    search_parser.add_argument(
        '--limit',
        type=int,
        help='Limit search results',
    )
    search_group = search_parser.add_mutually_exclusive_group()
    search_group.add_argument(
        '--local', '-l',
        action='store_true',
        help='Search installed packages (fuzzy match)'
    )
    search_group.add_argument(
        '--exact', '-e',
        action='store_true',
        help='Exact match on installed packages'
    )

    # info - show package info
    info_parser = subparsers.add_parser(
        'info',
        help='Show detailed package information'
    )
    info_parser.add_argument('package', help='Package name to inspect')
    info_parser.add_argument(
        '--local', '-l',
        action='store_true',
        help='Query installed package instead of sync repos'
    )

    # install - install package
    install_parser = subparsers.add_parser(
        'install',
        help='Install a package from sync repos'
    )
    install_parser.add_argument('package', help='Package name to install')

    # uninstall - remove package
    uninstall_parser = subparsers.add_parser(
        'uninstall',
        help='Uninstall a package'
    )
    uninstall_parser.add_argument('package', help='Package name to uninstall')
    uninstall_parser.add_argument(
        '--no-deps',
        action='store_true',
        help='Do not remove orphaned dependencies'
    )

    # repos - manage repositories
    repos_parser = subparsers.add_parser(
        'repos',
        help='List or toggle pacman.conf repositories'
    )
    repos_parser.add_argument(
        'toggle',
        nargs='?',
        help='Repository name to toggle on/off'
    )

    return parser

# parse with global flags
def main(argv=None) -> int:
    argv_list = list(argv if argv is not None else sys.argv[1:])
    commands = {
        'mirrors', 'sync', 'upgrade', 'check', 'clean', 'sif',
        'deps', 'list', 'search', 'info', 'install', 'uninstall', 'repos',
    }
    # Auto-insert 'search' if first arg isn't a command or flag
    if argv_list and not argv_list[0].startswith('-') and argv_list[0] not in commands:
        argv_list = ['search'] + argv_list

    parser = build_parser()
    args = parser.parse_args(argv_list)

    if getattr(args, 'no_color', False):
        g.USE_COLOR = False

    noconfirm = getattr(args, 'noconfirm', False)

    if args.command is None:
        parser.print_help()
        return 0

    try:
        if args.command == 'mirrors':
            sort_mirrors(
                protocol=args.protocol,
                latest=args.latest,
                sort=args.sort,
                country=args.country,
                dry_run=args.dry_run,
            )
        # dest root is ignored
        elif args.command == 'sync':
            op_a('syncing system')
            g.update_packages(
                dest_root=Path,
                refresh=False,
                noconfirm=noconfirm,
                update_system=True,
                include_devel=False,
                index_only=True,
                system_only=True,
            )

        elif args.command == 'upgrade':
            download_only = getattr(args, 'download', False)
            install_only = getattr(args, 'install', False)
            if download_only:
                op_a('downloading system updates')
            elif install_only:
                op_a('installing downloaded updates')
            else:
                op_a('upgrading system')
            g.update_packages(
                dest_root=Path,
                refresh=False,
                noconfirm=noconfirm,
                update_system=True,
                include_devel=False,
                system_only=True,
                download_only=download_only,
                install_only=install_only,
            )

        elif args.command == 'check':
            check_updates()

        elif args.command in ('clean', 'sif'):
            clean_packages()

        elif args.command == 'deps':
            show_dependencies(args.package)

        elif args.command == 'list':
            if args.sync:
                list_all(local=False)
            else:
                list_installed()

        elif args.command == 'search':
            # --exact implies local
            local = args.local or args.exact
            search_packages(args.package, local=local, exact=args.exact, limit=args.limit)

        elif args.command == 'info':
            inspect_package(args.package, local=args.local)

        elif args.command == 'install':
            # pkg- syntax means uninstall (like apt)
            if args.package.endswith('-'):
                remove_package(args.package[:-1], dependencies=True)
            else:
                install_package(args.package)

        elif args.command == 'uninstall':
            remove_package(args.package, dependencies=not args.no_deps)

        elif args.command == 'repos':
            if args.toggle:
                toggle_repo(args.toggle)
            else:
                op_a('listing repositories')
                for name, enabled in get_repos():
                    status = g.style('[enabled]', g.GREEN) if enabled else g.style('[disabled]', g.YELLOW)
                    print(f"  {name:<20} {status}")

        else:
            parser.error(f'Unknown command: {args.command}')

    except g.PacAurGitFpError as e:
        print(g.style(f'error: {e}', g.YELLOW), file=sys.stderr)
        return 1

    return 0

# handle kb exit and errors above
if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print(g.style('\nInterrupted by user', g.YELLOW), file=sys.stderr)
        sys.exit(130)

